---
title: "8.3 代数的データ型の関手性"
---

これまで，パラメータをとるデータ型が関手となっていて `fmap` を定義できるという例をいくつか見てきた．複雑なデータ型をシンプルなデータ型から作れる．とくに， **代数的データ型** (Algebraic Data Type: ADT) は和や積から組み立てることができる．和や積が関手的であるというのは既に見た．そして関手が結合的であることも既に知っている．だから，ADT の基本パーツが関手的だということが言えるなら，パラメータをとる ADT も関手的だと言えるだろう．

パラメータをとる代数的データ型の基本パーツとはなんだろうか？ まず，関手の型パラメータに依存しない部品が必要だ． `Maybe` における `Nothing` や， `List` における `Nil` がこれに相当する．これらは `Const` 関手に対応する．覚えておいて欲しいのは， `Const` 関手が型パラメータを無視するという点だ．（実際には第2の型パラメータは無視され，第1の型パラメータは保持される） (really, the second type parameter, which is the one of interest to us, the first one being kept constant.)

もう一つの基本パーツとして，型パラメータを単に包むだけ，というものもある． `Maybe` の `Just` がこれに相当する．これは恒等関手に対応する．恒等関手は圏の圏 $\mathbf{Cat}$ における恒等射という話はしたが，まだ Haskell で定義していなかったので書いておこう．

```haskell
data Identity a = Identity a
instance Functor Identity where
  fmap f (Identity x) = Identity (f x)
```

`Identity` は型 `a` の（変更不可能な）値を一つだけ保持するという，最もシンプルなコンテナだということが見えるだろう．

これら二つの基本パーツに対して積と和を使うことで，代数的データ型の残りが構成される．

この新しい知見をふまえて， `Maybe` 型コンストラクタを改めて眺めてみよう．

```haskell
data Maybe a = Nohting | Just a
```

これは二つの型の和であり，この和は関手的であるとわかる．ここで， `Nothing` は `Const ()` を `a` に作用させたものと書き直せる．^[訳注 `data Const c a = Const c` なので `Const () a` はいかなる `a` に対しても常に `Const ()` を返す]（ `Const` の第1型パラメータは単位元^[unit] に固定されているが，後ほど `Const` のより興味深い使われ方が登場する．）また `Just a` は名前が違うだけで要するに恒等関手だ． ということは，`Maybe` を型コンストラクタでなく同型射を使って書き直せる．

```haskell
type Maybe a = Either (Const () a) (Identity a)
```

つまり， `Maybe` は双関手 `Either` に `Const ()` と `Identity` を組み合わせたものだということだ．（ `Const` は本当は双関手なのだが，ここでは部分適用した状態で使っている．）

ここまでで，関手を組み合わせたら関手になるということを見てきた．同様のことが双関手についても成り立つことは想像に難くない．これを確認するには，二つの関手が射にたいしてうまく働くように ^[?] 双関手を合成する方法を見つければよい．2つの射に対して，それぞれを関手で持ち上げたもののペアが，双関手で持ち上げた射になる．

Haskell で書いてみよう．まずはひとつの双関手 `bf` （つまり二つの型を引数にとる型コンストラクタ）とふたつの関手 `fu`， `gu` （これはそれぞれ一つの型を引数にとる型コンストラクタ），そして二つの単なる型 `a`，`b` をパラメータに取るデータ型を定義する． `fu` を `a` に， `gu` を `b` に適用し，それを `bu` に与える．

```haskell
newtype Bicomp bf fu gu a b = BiComp (bf (fu a) (gu b))
```

これは対象あるいは型の合成である．Haskell では，関数に引数を与えるかのように型コンストラクタに型を与える．使う文法はおなじだ．

もし疑問があるなら，試しに `BiComp` に対して `Either`， `Const ()` ， `Identity`，`a`， `b` をこの順で与えたらどうなるか考えてみるといい．（`a` が無視されて，） `Maybe b` になることがわかるだろう．

この新しいデータ型 `BiComp` は `a` と `b` を取る双関手になるためには， `bf` が `Bifunctor` （双関手）で， `fu` と `gu` が関手でなければならない．つまり，コンパイラは `bf` の `bimap ` が定義されていることを知っている必要がある． Haskell では，これはインスタンス定義の前提として太い矢印の後ろに記述される．

```haskell
instance (Bifunctor bf, Functor fu, Functor gu) =>
  Bifunctor (BiComp bf fu gu) where
    bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x)
```

`BiComp` の `bimap` の実装は，`fu` と `gu` に対する `fmap` を引数とする `bf` の `bimap` になっている．コンパイラはすべての（関数と変数の）型を推論し，適切な関数ををオーバーロードする．

`bimap` がとる `x` の型はこうだ．

```haskell
bf (fu a) (gu b)
```

このインスタンス定義にはたくさんの意味が詰まっている．外側の `bimap` は上位の `bf` の階層とつながっているし，二つの `fmap` は `fu` と `gu` の階層とそれぞれつながっている． `f1` と `f2` の型がそれぞれ，

```haskell
f1 :: a -> a'
f2 :: b -> b'
```

ならば，最終的な返り値の型は `bf (fu a') (gu b')` になる．^[?]

```haskell
bimap :: (fu a -> fu a') -> (gu b -> gu b')
  -> bf (fu a) (gu b) -> bf (fu a') (gu b')
```

このような型操作は，ジグソーパズルのようなものだ．

ここまでの一連の議論で，我々は `Maybe` が関手であると証明する必要がないことがわかった．二つのより基本的な関手の直和であるということから示されるのだ．^[訳注 `Maybe` は `Const ()` と `Identity` の直和（ `Either` ）なのだった．]

鋭い読者は，次のような疑問を持つかもしれない．代数的データ型の `Functor` インスタンスがこんなに機械的に導けるなら，コンパイラで自動化できないものだろうか？ 実際可能であり，そういうものは存在する．次の行をソースの最初に追加することで， Haskell の機能拡張を有効にして，

```haskell
{-# LANGUAGE DeriveFunctor #-}
```

`deriving Functor` という記述をデータ構造の後ろにつければよい．つまり，こうだ．

```Haskell
data Maybe a = Nothing | Just a deriving Functor
```

これで，必要な `fmap` は自動的に生成される．

代数的データ型の規則性を利用すれば， `Functor` 以外にもいくつかの型クラスに対して同様のことが可能だ．たとえば以前登場した `Eq` 型クラスがそれにあたる．ユーザ定義の型クラスに対してのインスタンスをコンパイラに明示的に与えることもできるが，これは少し高度な話になる．考え方は一緒で，基本パーツのふるまい，直和，そして直積を与えれば，コンパイラが残りを生成してくれる．


（和訳：[@takase](https://zenn.dev/takase)）