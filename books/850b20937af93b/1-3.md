---
title: "1.3 合成はプログラミングの本質である"
---
関数型プログラマーは独特な問題解決法を持っている．彼らは禅問のような問いを立てることから始める．例えばインタラクティブなプログラムを設計する際，彼らは問う：「インタラクションとは何か？」 Conway のライフゲームを実装する際，恐らく彼らは生命の意味について深く考え始めるだろう．この精神に則り，私は問う：「プログラミングとは何か？」

最も基本的なレベルでは，プログラミングとはコンピュータに何をすべきか命令することである．「メモリアドレス `x` にある値を取り出しレジスタ `EAX` の値に足せ」という具合に．しかしアセンブリを書くときですら，我々がコンピュータに与える命令は何らかの意味を持つものであろう．我々は何かしら非自明な問題を解こうとしている（自明なのなら，コンピュータを使う必要すらない）．そして我々はどのようにその問題を解くだろうか．我々は大きい問題を小さな問題に分割していく．もしその小さな問題がまだ大きかったら，それをさらに小さくして行く．最終的には，我々は小さな問題を全て解決するコードを書く．そして次こそがプログラミングの本質である：我々はそれらのピースを統合（合成）して，大きな問題を解くプログラムを作る．統合ができないのなら，そもそも分解は意味を成さない．

この階層的な分解と統合のプロセスは，別にコンピュータが我々に要請しているものではない．これは人間の思考の限界を反映している．我々の脳は，いくつかの考察しか同時に行うことができない．心理学において最も引用されている論文 [The Magical Number Seven, Plus or Minus Two](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two) が立てた仮説によれば，我々は $7 \pm 2$ 個の "塊" の情報しか同時に頭に入れておくことができない．人間の短期記憶に関する学術的な詳細は今後変わるかも知れないが，とにかくとても限られているという事実は確実だ．少なくとも，オブジェクトのスープやコードのスパゲッティを扱うことはできない．

我々がプログラムに構造を必要とするのは，綺麗に構造化されたプログラムは見栄えが良いからではなく，さもなくば我々の脳は効率的に処理できないからだ．我々はしばしばコードをエレガントだとか美しいとか表現するが，それが意味するのは我々の限られた思考能力で簡単に処理できるということだ．エレガントなコードは，我々が消化し吸収するのに，ちょうど良いサイズの塊で，ちょうど良い個数で表現されている．

では，プログラムを統合する際の "ちょうどいい塊" とは何だろうか？ まず，その "表面積" は "体積" よりも緩やかに増えていかねばならない（私はこのアナロジーが好きだ．物体の表面積は長さの 2乗に比例して増大し，体積は 3乗に比例する）．ここで "表面積" とは，塊の合成に必要な情報を指し，"体積" とはその実装に必要な情報を指す．大切なのは，一度その塊が実装できたら，我々はその実装の詳細のことは忘れてよく，他の塊とどう関わるかに集中できるようになる．オブジェクト指向プログラミングでは，表面に当たるのがクラスまたは抽象的なインターフェースの宣言だ．関数型プログラミングでは，表面は関数の宣言である．（やや話を単純化しすぎだが，要点は外していないだろう．）

圏論は次の意味で極端だ：それは我々が対象の中身を見ようとすることを積極的に拒む．圏論における対象は抽象的で漠然としたモノだ．対象について知りうるのは，射（矢印）によって他の対象とどう関わるかということのみだ．インターネットの検索エンジンがページをランク付けするのはこの方法による（ただし不正がなければだが）．オブジェクト指向プログラミングでは，理想化されたオブジェクトは抽象的なインターフェースを通してのみ見ることができ（純粋な表面で，体積を持たないもの），メソッドが射の役割を果たす．もしオブジェクトの実装を掘り下げて，どう他のオブジェクトと関わるかを調べなければいけないのだとしたら，あなたはプログラミングパラダイムの利点を失ってしまっている．

（和訳：[@taketo1024](https://zenn.dev/taketo1024)）
