---
title: "13.1 Haskellでの自由モノイド"
---


\section{Free Monoid in Haskell}

A two-element set in Haskell is equivalent to the type \code{Bool},
and the free monoid generated by this set is equivalent to the type
\code{{[}Bool{]}} (list of \code{Bool}). (I am deliberately ignoring
problems with infinite lists.)

A monoid in Haskell is defined by the type class:

\src{snippet01}
This just says that every \code{Monoid} must have a neutral element,
which is called \code{mempty}, and a binary function (multiplication)
called \code{mappend}. The unit and associativity laws cannot be
expressed in Haskell and must be verified by the programmer every time a
monoid is instantiated.

The fact that a list of any type forms a monoid is described by this
instance definition:

\src{snippet02}
It states that an empty list \code{{[}{]}} is the unit element, and
list concatenation \code{(++)} is the binary operation.

As we have seen, a list of type \code{a} corresponds to a free monoid
with the set \code{a} serving as generators. The set of natural
numbers with multiplication is not a free monoid, because we identify
lots of products. Compare for instance:

\src{snippet03}
That was easy, but the question is, can we perform this free
construction in category theory, where we are not allowed to look inside
objects? We'll use our workhorse: the universal construction.

The second interesting question is, can any monoid be obtained from some
free monoid by identifying more than the minimum number of elements
required by the laws? I'll show you that this follows directly from the
universal construction.

（和訳：[@ashiato45](https://twitter.com/ashiato45)）
