---
title: "6-3. 直和型"
---

集合の圏の積から積の型が産まれたように，余積から直和型を作ることができる．Haskell における直和型の標準的な実装はこうだ．

```haskell
data Either a b = Left a | Right b
```

ペアと同じように， `Either` も（同型を除いて）可換であり，入れ子にでき，入れ子の順序は（同型を除いて）任意である．たとえば要素が3つであれば，次のようにすればよい．

```haskell
data OneOfThree a b c = Sinistral a | Medial b | Dextral c
```

$\mathbf{set}$ は余積を演算とする^[?]モノイダル圏^[さらに言えば対称モノイダル圏] である．このモノイダル圏では直和が二項演算で，単位元は始対象だ．型で言うなら，演算子としての `Either` ^[訳注： 型コンストラクタの `Either` ではない] と，`Void` がそれぞれに相当する．実際， `Void` を足しても中身に変化は無い．たとえば `a` に `Void` を足しても `a` と同型だ．

```haskell
Either a Void
```

`Void` 型は値を持たないので `Either` の `Right` （右側の）コンストラクタからは何も作れず， `Left` （左側の）コンストラクタから作れるのはカプセルに包まれた `a` だ．数式で書くなら， $a+0=a$ という意味になる．

直和型は Haskell ではよく使われるが， C++ でこれに相当する union や　variant はそれほどでもない．この理由はいくつかある．

まず第1に， C++ で単純な直和型が欲しければ列挙型 `enum` を使えばよいという点が挙げられる．色についての直和型を Haskell と C++ のそれぞれで書くと次のようになる．

```haskell
data Color = Red | Green | Blue
```

```cpp
enum { Red, Green, Blue };
```

もっと単純に真偽値ならば Haskell では次のような表現になるのだが，

```haskell
data Bool = True | False
```

C++ ならばプリミティブな `bool` 型を使うことだろう．

値が存在するか否かを表現することを考えると， C++ では何らかの「ありえない」値を利用することが多い．空の文字列や負の値，ヌルポインタなどだ．これを避けたいのなら， Haskell では次のように `Maybe` 型を使う．

```haskell
data Maybe a = Nothing | Just a
```

`Maybe` 型は二つの型の直和である．それぞれについては問題なく理解できるだろう．ひとつ目だけ抜き出すとこうなる．

```haskell
data NothingType = Nothing
```

`Nothing` だけを持つ列挙型で，要するにユニット型 `()` と等価なシングルトンだ．そしてふたつ目だけ抜き出すとこうなる．

```haskell
data JustType a = Just a
```

型 `a` を包んでいるだけだ．以上をふまえると， `Maybe` は次のようにもかけることがわかる．

```haskell
data Maybe a = Either () a
```

より複雑な直和型の場合， C++ ではポインタを使うこともある．このポインタは null か，あるいは特定の型の値をさす．リストを例にすると， Haskell では（再帰的な）直和で定義される．

```haskell
data List a = Nil |  Cons a (List a)
```

これを C++ で扱うにはヌルポインタで空リストを表現する．

```cpp
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {}
    List(A a, List<A> l)
      : _head(new Node<A>(a, l))
    {}
};
```

Haskell のコンストラクタ `Nil` と `Cons` は，オーバーロードされた `List` コンストラクタに対応する．（空なら `Nil`，値やリストなら `Cons`．） `List`クラスでは，直和型の二つの要素を区別するための目印は特に必要ない．^[?]

Haskell と C++ での大きな違いは， Haskell は値の上書きを許さない点だ．コンストラクタを使ってオブジェクトをつくったら，そのオブジェクトは自分が作られたときにどのコンストラクタにどんな引数が与えられたかを永遠に忘れない．したがって一度 `Just "energy"` としてつくられた `Maybe` のオブジェクトが `Nothing` に変化することは絶対にない．同様に空リストは永遠に空リストであり，要素が3つのリストの要素数は常に3つだ．

It’s this immutability that makes construction reversible. オブジェクトが与えられれば，そのオブジェクトがどのようにつくられたかまで必ず知ることができる．この操作はパターンマッチングでおこなうことができ，そのパターンはオブジェクトをつくったときのものが流用できる．`Nil` という空リストにマッチングするものと，`Cons` でつくられたリストにマッチングするものに分けられるだろう．たとえば `List` を取る関数 `maybeTail` を考える．

```haskell
maybeTail :: List a -> Maybe (List a)
maybeTail Nil = Nothing
maybeTail (Cons _ t) = Just t
```

`maybeTail` の定義の1行目ではコンストラクタ `Nil` にマッチングするものに対して `Nothing` を返すという定義している．2行目は，コンストラクタ `Cons` にマッチングしたら，興味の無い最初の部分をワイルドカード^[訳注: アンダースコア (_)] で捨てて，残りの部分を変数 `t` にバインドして `Just t` を返す．（ここでは便宜上変数と呼んでいるが，上書きできないので厳密には変数ではない．）その `List` がどのように作られたかによって，どちらにマッチングするかが決まる． `Cons` でつくられたなら，その時の2つの引数が取り出せるだろう．（そしてひとつ目は捨てられる．）

C++ では，直和型は多態性のクラス階層を使って実装される．同じ上位クラスを持つクラスが一つの型変数とみなし，その vtable がタグのように働く^[?]．Haskell がパターンマッチングでそれぞれのコードを呼び出すところを， C++ では仮想関数の呼び出しを使って vtable ポインタによりディスパッチするのだ．

C++ で `union` が直和型として使われているのを見ることはあまりないだろう．それは union に含めることができるものに厳しい制限がかかっているせいだ．「コピーコンストラクタを持ってはならない」という制限もあるため `std::string` すら union には入れられない．

（和訳：[@takase](https://zenn.dev/takase)）