---
title: "13.0 自由モノイド"
---

原文：[3. Free Monoids ](https://bartoszmilewski.com/2015/07/21/free-monoids/)

% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{M}{onoids are an important} concept in both category
theory and in programming. Categories correspond to strongly typed languages, 
monoids to untyped languages. That's because in a monoid you can compose any
two arrows, just as in an untyped language you can compose any two functions
(of course, you may end up with a runtime error when you execute your
program).

We've seen that a monoid may be described as a category with a single
object, where all logic is encoded in the rules of morphism composition.
This categorical model is fully equivalent to the more traditional
set-theoretical definition of a monoid, where we ``multiply'' two
elements of a set to get a third element. This process of
``multiplication'' can be further dissected into first forming a pair of
elements and then identifying this pair with an existing element ---
their ``product.''

What happens when we forgo the second part of multiplication --- the
identification of pairs with existing elements? We can, for instance,
start with an arbitrary set, form all possible pairs of elements, and
call them new elements. Then we'll pair these new elements with all
possible elements, and so on. This is a chain reaction --- we'll keep
adding new elements forever. The result, an infinite set, will be
\emph{almost} a monoid. But a monoid also needs a unit element and the
law of associativity. No problem, we can add a special unit element and
identify some of the pairs --- just enough to support the unit and
associativity laws.

Let's see how this works in a simple example. Let's start with a set of
two elements, $\{a, b\}$. We'll call them the generators of the
free monoid. First, we'll add a special element $e$ to serve as
the unit. Next we'll add all the pairs of elements and call them
``products''. The product of $a$ and $b$ will be the pair
$(a, b)$. The product of $b$ and $a$ will be the
pair $(b, a)$, the product of $a$ with $a$ will be
$(a, a)$, the product of $b$ with $b$ will be
$(b, b)$. We can also form pairs with $e$, like
$(a, e)$, $(e, b)$, etc., but we'll identify them with
$a$, $b$, etc. So in this round we'll only add
$(a, a)$, $(a, b)$ and $(b, a)$ and
$(b, b)$, and end up with the set
$\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/bunnies.jpg}
\end{figure}

\noindent
In the next round we'll keep adding elements like:
$(a, (a, b))$, $((a, b), a)$, etc. At this point we'll
have to make sure that associativity holds, so we'll identify
$(a, (b, a))$ with $((a, b), a)$, etc. In other words,
we won't be needing internal parentheses.

You can guess what the final result of this process will be: we'll
create all possible lists of $a$s and $b$s. In fact, if we
represent $e$ as an empty list, we can see that our
``multiplication'' is nothing but list concatenation.

This kind of construction, in which you keep generating all possible
combinations of elements, and perform the minimum number of
identifications --- just enough to uphold the laws --- is called a free
construction. What we have just done is to construct a \newterm{free
monoid} from the set of generators $\{a, b\}$.



（和訳：[@ashiato45](https://twitter.com/ashiato45)）
