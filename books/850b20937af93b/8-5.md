---
title: "8.5 Writer 関手"
---

前に，「クライスリー圏に戻ってくる」と約束した．クライスリー圏の射は，データ型 `Writer` を返す「装飾のついた」関数である．

```haskell
type Writer a = (a, String)
```

前に述べたように，この装飾部分は自己関手と少し関係している．そして実際のところ， `Writer` 型コンストラクタは `a` について関手的だ．これは単なる直積型なので， `fmap` を自分で実装する必要はない．

しかし，クライスリー圏と関手との関係，とは一体なんだろうか？ クライスリー圏とは圏の一種で，合成と恒等関手を持つのだった．子の合成はフィッシュ演算子 ^[fish operator] で与えられることを思い出しておこう．

```haskell
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
m1 >=> m2 = \x ->
  let (y, s1) = m1 x
      (z, s2) = m2 y
  in (z, s1 ++ s2)
```

恒等射は `return` と呼ばれる関数で与えられる．

```haskell
return :: a -> Writer a
return x = (x, "")
```

これら二つの関数をよーーーく眺めると， `fmap` の型シグネチャにあうようにまとめられることがわかるだろう．こうだ．

```haskell
fmap f = id >=> (\x -> return (f x))
```

フィッシュ演算子は二つの関数を結合している．ひとつは慣れ親しんだ `id` で，もうひとつは引数に対して `f` を適用した結果を `return` するという無名関数だ．一番ひっかかるのは `id` の使われ方だろう．フィッシュ演算子の引数は，「普通の」型を取って装飾された型を返す関数だったのではないか？ 実はそうでもない．一体いつから `a -> Writer b` の `a` が「普通の」型だと錯覚していた？ `a` は型変数であり，何でもよいのだ．たとえば `Writer b` のように装飾された型でもよいのだ．

`id` は `Writer a` をとったら `Writer a` を返す．フィッシュ演算子は `a` の値をつり上げて，無名関数の `x` として渡す．そして `f` は `b` を返し，それを `return` が装飾して `Writer b` を作る．つまり `id` は `Writer a` を取って `Writer b` を返すということになり，これはまさに `fmap` だ．

気をつけたいのは，この引数はとても汎用的だということだ． `Writer` を任意の他の型コンストラクタに置き換えることもできる．フィッシュ演算子と `return` をサポートしてさえいれば， `fmap` を定義できるのだ．だからクライスリー圏による装飾は関手になれる．（が，すべての関手がクライスリー圏になれるわけではない．）

手で実装した `fmap` とコンパイラが `deriving` で導出した `fmap` が同じものか不安になる読者もいるかもしれない．興味深いことに，その心配はいらない．これは，Haskell が多相型の関数として実装するためで， "theorems for free" に由来するいわゆる **パラメータ多相** (parametric polymorphism) である．これらの理論によれば，所与の型コンストラクタに対する `fmap` が存在し，それが恒等射を保つなら，それは一意でなければならないのだ．

（和訳：[@takase](https://zenn.dev/takase)）