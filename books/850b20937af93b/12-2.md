---
title: "12.2 極限の例"
---

ここまで我々は，圏論的な積は$\mathbf{2}$とよばれる簡単な圏によって生成された図式の極限であることを見てきた．

極限の例にはもっとずっと簡単なものがある: 終対象だ．すぐに想像するのはシングルトン圏が終対象を導くということだろうが，真実はもっとずっと飾り気のないものだ: 終対象は空圏(empty category)から生成される．空圏からの関手は何の対象も選ばず，したがって錐はただの頂点に収縮する．普遍錐はどの他の頂点からもそこに来る唯一の射を持つような孤独な頂点である．これが終対象の定義であることはわかるだろう．

次の面白い極限は **イコライザ(equalizer)** とよばれる．これは2つの対象とそれらの間を走る2つの並行な射(といつもどおり，恒等射たち)のなす圏から生成される極限である．この圏は2つの対象$a$と$b$，そして2つの射からなるような図式を$\mathbf{C}$のなかから選ぶ:

$$
f \mathtt{::}\   a \to b\\
g \mathtt{::}\   a \to b
$$

この図式の上に錐を作るには，頂点$c$と2つの射影を追加することになる:

$$
p\mathtt{::}\   c \to a\\
q\mathtt{::}\   c \to b
$$

![](https://storage.googleapis.com/zenn-user-upload/2ulwiqlx7tvrrcxlnx64h6lf22e6)

可換でなければいけなような三角形が2つできる:

$$
q = f.p\\
q = g.p
$$

これは，$q$はこれらの等式のうちの1つ(たとえば$q=f.p$のほう)で唯一つに決定されると言っており，$q$を図から取り除くことができる．すると，1つの条件だけが残ることになる:

$$
f.p = g.p
$$

これについて考える方法はこうだ．$\mathrm{Set}$に注意を集中すると，関数$p$の像は$a$の部分集合を定める．この集合に制限すれば，関数$f$と$g$は等価である．

例えば，$a$を$x$座標と$y$座標でパラメタ付けされた2次元平面だとしよう．$b$は実直線とし，さらに次を取る:

$$
\begin{aligned}
f~(x, y) &= 2 * y + x\\
g~(x, y) &= y - x
\end{aligned}
$$

これら2つの関数についてのイコライザは実数の集合(頂点$c$)と関数

$$
p~t = (t, (-2) * t)
$$

である．

$(p~t)$はこの二次元平面中で直線を定義することに注意しよう．この線に沿って，先の2つの関数は等価である．

もちろん，他にもこの等価性を導くような他の集合$c'$と関数$p'$も存在する:

$$
f.p' = g.p'
$$

が，そういったものは$p$を通して唯一な方法で分解される．例えば，$c'$としてシングルトン集合$\{()\}$をとり[^1]，関数として次を取る:

$$
p'~() = (0, 0)
$$

これはちゃんと錐になっている．なぜなら，$f~(0, 0) = g~(0, 0)$となっているからである．しかし，これは普遍的ではない．なぜなら，次のような唯一の分解$h$が存在するからである:

$$
p' = p.h
$$

ただし，

$$
h~() = (0, 0)
$$

![](https://storage.googleapis.com/zenn-user-upload/gvkrg0yuvkc0bmgh3cnzcve39onj)

そういうわけで，イコライザは$f~x = g~x$というタイプの等式を解くのに使うことができる．しかし，イコライザはもっと一般的なものである．なぜなら，これは代数学的にではなく対象と射の言葉で定義されているからだ．

等式を解く，というのをもっと一般的にした考え方はまた別の極限にあらわれている --- 引き戻し(pullback)である．今回も等価にしたい2つの射がやっぱりあるのだが，今度はそれらの定義域が異なる．次の形の3つ対象のある圏からはじまる: $1\rightarrow2\leftarrow3$．この圏に対応する図式は2つの対象$a, b, c$と2つの射:


$$
f \mathtt{::}\   a \to b\\
g \mathtt{::}\   c \to b
$$

から成る．

この図式はしばしば **余スパン(cospan)** とよばれる．

この図式の上にできる錐は頂点$d$と3つの射からなる:

$$
p \mathtt{::}\   d \to a\\
q \mathtt{::}\   d \to c\\
r \mathtt{::}\   d \to b
$$

![](https://storage.googleapis.com/zenn-user-upload/faf3k3frh1nacp805x1frqf6fv8i)

可換性条件は$r$が他の射たちによって完全に決定されるということを言っており，図から取り除くことができる．なので，次の条件だけが残る:

$$
g.q = f.p
$$

引き戻しはこの形の普遍錐である．

![](https://storage.googleapis.com/zenn-user-upload/2fnoskqvzfk27ctkxu8k69n0qlp9)

再び集合だけに焦点を当てるなら，対象$d$は$a$と$c$の元からなるペアであって，$f$が最初の要素に作用したものは$g$が2番目の要素に作用したものと同じであるようなものと思うことができる．これでも一般的すぎるというのなら，$g$が定数関数($g~\_=1.23$ということにしよう)であるという特別な場合を考えてみるとよい($b$は実数値の集合だと仮定している)．すると，次の等式を解いていることになる:

$$
f~x = 1.23
$$

この場合，$c$の選択は(これが空集合でない限り)関係がなく，したがってシングルトン集合として取ることができる．例えば，集合$a$は3次元ベクトルの集合で，$f$がベクトルの長さとしよう．すると，引き戻しはペア$(v, ())$の集合(ただし$v$は長さ1.23のベクトルであり，等式$\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23$の解)であり，$()$はシングルトン集合のダミー元である．

しかし引き戻しはもっと一般的な応用があり，プログラミングにも使える．例えばC++のクラスを，射がサブクラスとスーパークラスとを繋ぐ矢印である圏として考えよう．継承は推移的な性質だと考えられるので，もし`C`が`B`を継承し，`B`が`A`を継承しているなら，`C`は`A`を継承している(だって，`C`へのポインタを`A`へのポインタが期待されているところに渡すことはできるでしょう)．また，すべてのクラスが恒等射を持つように，`C`は`C`を継承していると仮定することにする．このようにして，サブクラス関係はサブタイピングと整合するようになる．C++はまた多重継承をサポートしているので，2つのクラス`B`と`C`が`A`を継承し，4番目のクラス`D`が`B`と`C`を多重に継承しているというダイヤモンド継承の図式を構成することができる．普通，`D`は`A`の2つのコピーを持つことになるが，これは全く望まれることではない．しかし，`D`に`A`のコピーを1つだけ持つように仮想継承を使うことができる．

`D`をこの図式の引き戻しにすることは何を意味するのだろう？これは`B`と`C`とを多重に継承するどんなクラス`E`もまた`D`のサブクラスであることを意味している．これを(サブタイピングが名前で行なわれる)C++で直接表現することはできない(C++コンパイラがこの種のクラス関係を推論することはないだろう --- これには「ダックタイピング」が必要だ)．しかし，サブタイピング関係の外側に出て，`E`から`D`へのキャストが安全かどうかを代わりに問うことはできる．このキャストは，`D`が`B`と`C`とを(追加のデータやメソッドのオーバーライドなしに)そのまま組み合わせたものなら安全だろう．そしてもちろん，`B`と`C`とのメソッドたちの間に名前の衝突があるなら，引き戻しは存在し得ない．

![](https://storage.googleapis.com/zenn-user-upload/kw3mor9ual1z1qo6kwfxm98qq3mj)

型推論では引き戻しのもっと進んだ使い方もある．しばしば，2つの式の型を **単一化(unify)** する必要がある．例えば，コンパイラにある関数の型を推論してほしいとしよう:

```haskell
twice f x = f (f x)
```

コンパイラは，すべての変数と部分式に準備の型を割り当てる．具体的には，このように割り当てられるだろう:

```haskell
f       :: t0
x       :: t1
f x     :: t2
f (f x) :: t3
```

ここから次が推論される:

```haskell
twice :: t0 -> t1 -> t3
```

コンパイラは関数適用のルールから結論づけられる制約の集合を見つけもする:

```haskell
t0 = t1 -> t2 -- fはxに適用されるから 
t0 = t2 -> t3 -- fは(f x)に適用されるから
```

両方の式の未知の型を置換したときに同じ型を生成するような型(あるいは型変数)の集合を見つけることによって，これらの制約は単一化されることになる．そのような置換の1つは:

```
t1 = t2 = t3 = Int 
twice :: (Int -> Int) -> Int -> Int
```

だが，明らかにこれは最も一般的なものではない．最も一般的な置換は引き戻しによって得られる．この本の範疇から外れるので詳細には踏み込まないが，その結果は次のようになるだろうということで納得してほしい:

```haskell
twice :: (t -> t) -> t -> t
```

ここで，`t`は自由な型変数である．


[^1]: 訳注: シングルトン集合は1元からなる集合で，圏論の本だとそのただ1つの元は★などで表示されることが多いです．この本では，Haskellのunit typeが取りうるただ1つの値``()``を使っているようです．

（和訳：[@ashiato45](https://twitter.com/ashiato45)）
