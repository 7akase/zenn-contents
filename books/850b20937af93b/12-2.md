---
title: "12.1 000"
---
\section{Examples of Limits}

We've seen that the categorical product is a limit of a diagram
generated by a simple category we called $\cat{2}$.

There is an even simpler example of a limit: the terminal object. The
first impulse would be to think of a singleton category as leading to a
terminal object, but the truth is even starker than that: the terminal
object is a limit generated by an empty category. A functor from an
empty category selects no object, so a cone shrinks to just the apex.
The universal cone is the lone apex that has a unique morphism coming to
it from any other apex. You will recognize this as the definition of the
terminal object.

The next interesting limit is called the \emph{equalizer}. It's a limit
generated by a two-element category with two parallel morphisms going
between them (and, as always, the identity morphisms). This category
selects a diagram in $\cat{C}$ consisting of two objects, $a$ and
$b$, and two morphisms:

\src{snippet03}

To build a cone over this diagram, we have to add the apex, $c$
and two projections:

\src{snippet04}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/equalizercone.jpg}
\end{figure}

\noindent
We have two triangles that must commute:

\src{snippet05}

This tells us that $q$ is uniquely determined by one of these
equations, say, \code{q = f . p}, and we can omit it from the
picture. So we are left with just one condition:

\src{snippet06}

The way to think about it is that, if we restrict our attention to
$\Set$, the image of the function $p$ selects a subset of
$a$. When restricted to this subset, the functions $f$ and
$g$ are equal.

For instance, take $a$ to be the two-dimensional plane
parameterized by coordinates $x$ and $y$. Take $b$
to be the real line, and take:

\src{snippet07}

The equalizer for these two functions is the set of real numbers (the
apex, $c$) and the function:

\src{snippet08}

Notice that $(p~t)$ defines a straight line in the
two-dimensional plane. Along this line, the two functions are equal.

Of course, there are other sets $c'$ and functions
$p'$ that may lead to the equality:

\src{snippet09}

but they all uniquely factor out through $p$. For instance, we
can take the singleton set $\cat{()}$ as $c'$ and the
function:

\src{snippet10}

It's a good cone, because $f (0, 0) = g (0, 0)$. But it's
not universal, because of the unique factorization through $h$:

\src{snippet11}

with

\src{snippet12}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/equilizerlimit.jpg}
\end{figure}

\noindent
An equalizer can thus be used to solve equations of the type
$f~x = g~x$. But it's much more general, because it's defined
in terms of objects and morphisms rather than algebraically.

An even more general idea of solving an equation is embodied in another
limit --- the pullback. Here, we still have two morphisms that we want
to equate, but this time their domains are different. We start with a
three-object category of the shape:
$1\rightarrow2\leftarrow3$. The diagram corresponding to
this category consists of three objects, $a$, $b$, and
$c$, and two morphisms:

\src{snippet13}

This diagram is often called a \emph{cospan}.

A cone built on top of this diagram consists of the apex, $d$,
and three morphisms:

\src{snippet14}

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/pullbackcone.jpg}
\end{figure}

\noindent
Commutativity conditions tell us that $r$ is completely
determined by the other morphisms, and can be omitted from the picture.
So we are only left with the following condition:

\src{snippet15}
A pullback is a universal cone of this shape.

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/pullbacklimit.jpg}
\end{figure}

\noindent
Again, if you narrow your focus down to sets, you can think of the
object $d$ as consisting of pairs of elements from $a$ and
$c$ for which $f$ acting on the first component is equal
to $g$ acting on the second component. If this is still too
general, consider the special case in which $g$ is a constant
function, say $g~\_ = 1.23$ (assuming that $b$ is a set
of real numbers). Then you are really solving the equation:

\src{snippet16}

In this case, the choice of $c$ is irrelevant (as long as it's
not an empty set), so we can take it to be a singleton set. The set
$a$ could, for instance, be the set of three-dimensional vectors,
and $f$ the vector length. Then the pullback is the set of pairs
$(v, ())$, where $v$ is a vector of length 1.23 (a
solution to the equation $\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23$), and
$()$ is the dummy element of the singleton set.

But pullbacks have more general applications, also in programming. For
instance, consider C++ classes as a category in which morphism are
arrows that connect subclasses to superclasses. We'll consider
inheritance a transitive property, so if \code{C} inherits from \code{B} and \code{B}
inherits from \code{A} then we'll say that \code{C} inherits from \code{A} (after all, you
can pass a pointer to \code{C} where a pointer to \code{A} is expected). Also, we'll
assume that \code{C} inherits from \code{C}, so we have the identity arrow for every
class. This way subclassing is aligned with subtyping. C++ also supports
multiple inheritance, so you can construct a diamond inheritance diagram
with two classes \code{B} and \code{C} inheriting from \code{A}, and a fourth class \code{D}
multiply inheriting from \code{B} and \code{C}. Normally, \code{D} would get two copies of \code{A},
which is rarely desirable; but you can use virtual inheritance to have
just one copy of \code{A} in \code{D}.

What would it mean to have \code{D} be a pullback in this diagram? It would
mean that any class \code{E} that multiply inherits from \code{B} and \code{C} is also a
subclass of \code{D}. This is not directly expressible in C++, where subtyping
is nominal (the C++ compiler wouldn't infer this kind of class
relationship --- it would require ``duck typing''). But we could go
outside of the subtyping relationship and instead ask whether a cast
from \code{E} to \code{D} would be safe or not. This cast would be safe if \code{D} were the
bare-bone combination of \code{B} and \code{C}, with no additional data and no
overriding of methods. And, of course, there would be no pullback if
there is a name conflict between some methods of \code{B} and \code{C}.

\begin{figure}[H]
\centering
\includegraphics[width=0.25\textwidth]{images/classes.jpg}
\end{figure}

\noindent
There's also a more advanced use of a pullback in type inference. There
is often a need to \emph{unify} types of two expressions. For instance,
suppose that the compiler wants to infer the type of a function:

\begin{snip}{haskell}
twice f x = f (f x)
\end{snip}
It will assign preliminary types to all variables and sub-expressions.
In particular, it will assign:

\begin{snip}{haskell}
f       :: t0
x       :: t1
f x     :: t2
f (f x) :: t3
\end{snip}
from which it will deduce that:

\begin{snip}{haskell}
twice :: t0 -> t1 -> t3
\end{snip}
It will also come up with a set of constraints resulting from the rules
of function application:

\begin{snip}{haskell}
t0 = t1 -> t2 -- because f is applied to x 
t0 = t2 -> t3 -- because f is applied to (f x)
\end{snip}
These constraints have to be unified by finding a set of types (or type
variables) that, when substituted for the unknown types in both
expressions, produce the same type. One such substitution is:

\begin{snip}{haskell}
t1 = t2 = t3 = Int 
twice :: (Int -> Int) -> Int -> Int
\end{snip}
but, obviously, it's not the most general one. The most general
substitution is obtained using a pullback. I won't go into the details,
because they are beyond the scope of this book, but you can convince
yourself that the result should be:

\begin{snip}{haskell}
twice :: (t -> t) -> t -> t
\end{snip}
with \code{t} a free type variable.

\section{Colimits}

Just like all constructions in category theory, limits have their dual
image in opposite categories. When you invert the direction of all
arrows in a cone, you get a co-cone, and the universal one of those is
called a colimit. Notice that the inversion also affects the factorizing
morphism, which now flows from the universal co-cone to any other
co-cone.

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/colimit.jpg}
\caption{Cocone with a factorizing morphism $h$ connecting two apexes.}
\end{figure}

\noindent
A typical example of a colimit is a coproduct, which corresponds to the
diagram generated by $\cat{2}$, the category we've used in the
definition of the product.

\begin{figure}[H]
\centering
\includegraphics[width=0.35\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
Both the product and the coproduct embody the essence of a pair of
objects, each in a different way.

Just like the terminal object was a limit, so the initial object is a
colimit corresponding to the diagram based on an empty category.

The dual of the pullback is called the \emph{pushout}. It's based on a
diagram called a span, generated by the category
$1\leftarrow2\rightarrow3$.

\section{Continuity}

I said previously that functors come close to the idea of continuous
mappings of categories, in the sense that they never break existing
connections (morphisms). The actual definition of a \emph{continuous
functor} $F$ from a category $\cat{C}$ to $\cat{C'}$ includes the
requirement that the functor preserve limits. Every diagram $D$
in $\cat{C}$ can be mapped to a diagram $F \circ D$ in $\cat{C'}$ by
simply composing two functors. The continuity condition for $F$
states that, if the diagram $D$ has a limit $\Lim[D]$, then
the diagram $F \circ D$ also has a limit, and it is equal to
$F (\Lim[D])$.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{images/continuity.jpg}
\end{figure}

\noindent
Notice that, because functors map morphisms to morphisms, and
compositions to compositions, an image of a cone is always a cone. A
commuting triangle is always mapped to a commuting triangle (functors
preserve composition). The same is true for the factorizing morphisms:
the image of a factorizing morphism is also a factorizing morphism. So
every functor is \emph{almost} continuous. What may go wrong is the
uniqueness condition. The factorizing morphism in $\cat{C'}$ might not be
unique. There may also be other ``better cones'' in $\cat{C'}$ that were
not available in $\cat{C}$.

A hom-functor is an example of a continuous functor. Recall that the
hom-functor, $\cat{C}(a, b)$, is contravariant in the first variable
and covariant in the second. In other words, it's a functor:
\[\cat{C}^{op} \times \cat{C} \to \Set\]
When its second argument is fixed, the hom-set functor (which becomes
the representable presheaf) maps colimits in $\cat{C}$ to limits in
$\Set$; and when its first argument is fixed, it maps limits to
limits.

In Haskell, a hom-functor is the mapping of any two types to a function
type, so it's just a parameterized function type. When we fix the second
parameter, let's say to \code{String}, we get the contravariant
functor:

\src{snippet17}
Continuity means that when \code{ToString} is applied to a colimit,
for instance a coproduct \code{Either b c}, it will produce a limit;
in this case a product of two function types:

\src{snippet18}
Indeed, any function of \code{Either b c} is implemented as a case
statement with the two cases being serviced by a pair of functions.

Similarly, when we fix the first argument of the hom-set, we get the
familiar reader functor. Its continuity means that, for instance, any
function returning a product is equivalent to a product of functions; in
particular:

\src{snippet19}
I know what you're thinking: You don't need category theory to figure
these things out. And you're right! Still, I find it amazing that such
results can be derived from first principles with no recourse to bits
and bytes, processor architectures, compiler technologies, or even
lambda calculus.

If you're curious where the names ``limit'' and ``continuity'' come
from, they are a generalization of the corresponding notions from
calculus. In calculus limits and continuity are defined in terms of open
neighborhoods. Open sets, which define topology, form a category (a
poset).

\section{Challenges}

\begin{enumerate}
\tightlist
\item
  How would you describe a pushout in the category of C++ classes?
\item
  Show that the limit of the identity functor
  $\mathbf{Id} \Colon \cat{C} \to \cat{C}$ is the initial object.
\item
  Subsets of a given set form a category. A morphism in that category is
  defined to be an arrow connecting two sets if the first is the subset
  of the second. What is a pullback of two sets in such a category?
  What's a pushout? What are the initial and terminal objects?
\item
  Can you guess what a coequalizer is?
\item
  Show that, in a category with a terminal object, a pullback towards
  the terminal object is a product.
\item
  Similarly, show that a pushout from an initial object (if one exists)
  is the coproduct.
\end{enumerate}


（和訳：[@ashiato45](https://twitter.com/ashiato45)）
