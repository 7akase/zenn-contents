---
title: "4.1 Writer圏"
---

すでにある関数の返り値を装飾することで機能を付加する，という考え方はとても有用である．このような例はたくさんある．出発地点はおなじみの型と関数の圏で，対象は型のままで，射は「装飾された関数」とする．

たとえば `int` を取り `bool` を返す関数 `isEven` を装飾するとする．これには対応する射がある．この射はペアを返すのだが，`int` から `bool` への射だと見るのが重要なポイントだ．

```cpp
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
```

圏論のルールによれば，この射は `bool` からの射であれば何であれ合成出来なければならない．具体的には，以前登場した `negate` 関数とは合成できるということだ．

```cpp
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
```

入力と出力が一致していないので，普通の関数を合成するようにはいかないのは明らかだ．合成するにはこのようにしなければいけない．

```cpp
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
```

新たな「装飾付き関数の圏」において，射を合成するためのレシピはこうだ．

1．第1の射に対応する装飾付き関数を実行して第1の実行結果を得る．
2. その結果から第1要素を取り出して，第2の射に対応する装飾付き関数を実行して第2の実行結果を得る．
3. 第1の実行結果と第2の実行結果から，それぞれの第2成分（文字列）を取り出して連結する．
4. 最終結果が第1要素で，連結した文字列を第2要素となるペアを返す．

このレシピを C++ の高階関数にするなら，3つの型をパラメータとして持つテンプレートになる．この3つは，「装飾付き関数の圏」の対象に対応している．この高階関数は，前述のレシピで合成可能な2つの装飾付き関数を引数にとり，新たに第3の装飾済み関数を返す．

```cpp
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    }
}
```

このテンプレートを，先ほどの `toUpper` と `toWords` の合成の例に適用するとこうなる．

```cpp
Writer<vector<string>> process(string s) {
    return compose<string, string, vector<string>>(toUpper, toWords)(s);
}
```

だが， `compose` テンプレートにいちいち型を渡さねばならないのは煩わしい．これは，返り値の型推論つきの汎用ラムダ関数に対応した C++14 対応コンパイラを使えば回避できる．（次のコードは Eric Niebler によるものだ．）

```cpp
auto const compose = [](auto m1, auto m2) {
    return [m1, m2](auto x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    }
}
```

この新しい定義によれば，関数 `prosess` は次のようにシンプルになる．

```cpp
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
```

だがまだ終わりではない．新しい圏に対して合成を定義したが，恒等射はどうだろうか．これは今まで見てきた恒等射とは違うものになる！ この恒等射は，型 A から型 A への射であり，つぎのような形になる．

```cpp
Writer<A> identity(A);
```

また，この恒等射は合成引退して単位元の役割を果たさねばならない．合成の定義からすると，この恒等射は引数をそのまま返し，ログにも何も加えないでいるべきだ．

```cpp
template<class A> Writer<A> identity(A x){
    return make_pair(x, "");
}
```

この圏が圏としてのルールを守っていることは容易に確認できるだろう．とくに合成は結合律を満たすことはすぐにわかる．それぞれのペアの第1要素だけに注目すれば単なる関数合成なので結合的になっているし，第2要素は文字列の連結なのでこちらも結合的だ．

このような構成が文字列モノイドに限らず任意のモノイドに一般化できるのではないか，と気づいた読者はとても鋭い． `compose` の `+` を `mappend` に， `identity` の `""` を`mempty` に置き換えるのだ．これにより，文字列でないログを生成することも可能になった．優れたライブラリ作成者は，ライブラリが機能する最小限の制約を見極めることができるものだ．このログ生成ライブラリについていえば，最小限の制約とは，ログがモノイド的である，ということだ．

（和訳：[@takase](https://zenn.dev/takase)）